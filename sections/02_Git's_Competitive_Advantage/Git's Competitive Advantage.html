<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Git's Competitive Advantage</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../styles/classless.css" />
</head>
<body>
<h1 id="gits-competitive-advantage">Git’s Competitive Advantage</h1>
<blockquote>
<p>“Git isn’t just a version control system; it’s a framework of trust.
A record of vision. A space where every branch reflects thought, and
every commit carries intent.” <em>—Mohamed Yasser</em></p>
</blockquote>
<p>In the spring of 2005, Linus Torvalds found himself facing an
unexpected crisis. The Linux kernel project, which had grown from his
personal experiment into a global collaboration with thousands of
developers, was suddenly without its version control system. BitKeeper,
the proprietary tool that managed the kernel’s development for three
years, was no longer available to the open-source community after a
licensing dispute. With characteristic pragmatism and impatience,
Torvalds surveyed alternatives like CVS and Subversion and found them
all lacking. They were too slow, too centralized, or simply inadequate
for the scale and distributed nature of the Linux kernel
development.</p>
<p>Rather than compromise or wait for someone else to solve the problem,
Torvalds began a two-week coding sprint that produced the initial
version of Git. Drawing on his experience with BitKeeper’s distributed
model but rejecting its complexity, he designed a system that was
blindingly fast, fully distributed, and robust enough for the kernel’s
sprawling development. By April 2005, Git was managing its own source
code. Within months, it proved capable of handling one of the world’s
most complex software projects, setting the stage for its eventual
dominance in version control.</p>
<hr />
<h2 id="what-youll-learn">What You’ll Learn</h2>
<p>This guide explores the architectural decisions that give Git its
competitive advantages. By the end, you’ll understand:</p>
<ul>
<li><p>How Git’s snapshot-based model differs fundamentally from
traditional delta-based VCSs</p></li>
<li><p>How Git’s three-state architecture enables flexible and powerful
workflows</p></li>
<li><p>Why cryptographic hashing makes Git more reliable than its
predecessors.</p></li>
<li><p>The trade-offs made to achieve Git’s exceptional
performance.</p></li>
</ul>
<hr />
<h2 id="gits-design-philosophy">Git’s Design Philosophy</h2>
<p>When Torvalds set out to build Git, he wasn’t simply creating another
version control system. He was solving specific problems that had
frustrated him during Linux kernel development; problems that existing
tools failed to address.</p>
<p>Git’s design reflects core priorities that distinguish it from
competitors:</p>
<ol type="1">
<li><p><strong>Speed at scale:</strong> The Linux kernel repository
contained thousands of files and years of history. Git needed to handle
commits, branches, and merges in seconds, not minutes. This requirement
influenced every architectural decision, from how Git stores data to how
it tracks changes.</p></li>
<li><p><strong>Distributed integrity:</strong> With thousands of
developers worldwide contributing code, Git required assurances that
repository history could not be corrupted or tampered with, either
accidentally or maliciously. Every object in Git is checksummed, making
it nearly impossible to change any file, date, or commit message without
Git detecting it.</p></li>
<li><p><strong>Non-linear development:</strong> Kernel development
involved creating, modifying, and daily merging of hundreds of
experimental branches. Git needed to make branching and merging
lightweight and reliable so developers would not hesitate to create
branches for minor experiments.</p></li>
</ol>
<p>These priorities led to architectural choices that set Git apart from
its predecessors and distributed contemporaries.</p>
<h3 id="thinking-in-snapshots">Thinking in Snapshots</h3>
<p>The most fundamental distinction between Git and most other VCSs lies
in how it conceptualizes data. Most systems, including CVS, Subversion,
and Perforce, store information as a list of file changes. They maintain
a base version of each file, then record the differences (deltas)
between versions. This is known as <em>delta-based</em> version
control.</p>
<figure>
<img src="assets/delta_based_vcs_illustrated.png"
alt="Delta-Based Version Control Illustrated" />
<figcaption aria-hidden="true">Delta-Based Version Control
Illustrated</figcaption>
</figure>
<p>When you want version 5 of a file, the system starts with the base
version and applies delta 1, then delta 2, then delta 3, and so on until
it reconstructs the version you requested. This approach mirrors how we
think about file modifications and can be space-efficient for certain
workflows, especially when files undergo frequent small changes.</p>
<p>Git rejects this model entirely. Instead of storing deltas, Git takes
a complete snapshot of your project at each version. When you commit a
version, Git captures a snapshot of what every file in your project
looks like at that moment and stores a reference to that snapshot. This
means Git views its data as a series of snapshots, rather than a series
of incremental changes.</p>
<figure>
<img src="assets/snapshot_based_vcs_illustrated.png"
alt="Snapshot-Based Version Control Illustrated" />
<figcaption aria-hidden="true">Snapshot-Based Version Control
Illustrated</figcaption>
</figure>
<p>This architectural decision has profound implications for performance
and workflow. When you checkout a previous version of your project, Git
doesn’t need to reconstruct it by walking through a chain of deltas. It
simply retrieves the snapshot directly. This enables operations such as
switching branches, viewing history, or comparing versions to be
performed extraordinarily fast. Even in repositories with thousands of
files and years of history, these operations typically complete in
milliseconds.</p>
<h3 id="built-in-integrity">Built-in Integrity</h3>
<p>Every piece of data in Git is checksummed before it is stored and
then referred to by that checksum. This means it’s impossible to change
the contents of any file or directory in a Git project without Git being
aware of it. This isn’t a feature you enable or a setting you configure;
it’s fundamental to how Git stores and references data.</p>
<p>The mechanism Git uses for checksumming is called <a
href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a> (Secure Hash
Algorithm 1). This hash function takes any input, a file, a directory
structure, or a commit object, and produces a 40-character hexadecimal
string composed of the digits <code>0-9</code> and letters
<code>a-f</code>. The crucial property of this hash is that it’s
deterministic: the same input always produces the same hash, but even
the tiniest change to the input produces a completely different
hash.</p>
<p>For example, the hash for the current commit of the directory holding
these lecture notes is:</p>
<pre><code>273b1294419ffbce11002241aff9d0839eb1172c</code></pre>
<p>And even though I’ve only added (this) one sentence, now the hash
is:</p>
<pre><code>12a78e5086ae51ed0be88bfa3b3ebd1bd5c88d38</code></pre>
<p>This string isn’t random or arbitrarily assigned. It’s a mathematical
fingerprint of the exact contents of that commit: the files it contains,
the commit message, the author information, the timestamp, and the hash
of its parent commit. Change any single character in any file, alter the
commit message by one letter, or modify the timestamp by one second, and
you’ll get an entirely different hash.</p>
<hr />
<h2 id="the-three-file-states">The Three File States</h2>
<p>Intuitively, one would expect a version control system to manage
files in two states: <strong>modified</strong> or
<strong>unmodified</strong>. Upon committing, the system would mark the
changes and call every file unmodified. Git, on the other hand,
introduces an intermediate stage that enables more fine-grained control
over commits and workflow. The three distinct states are:</p>
<ol type="1">
<li><p><strong>Modified:</strong> You’ve changed a file but haven’t yet
told Git to record that change.</p></li>
<li><p><strong>Staged:</strong> You’ve marked a file in its current
state to go into your next snapshot. This is the intermediate
stage.</p></li>
<li><p><strong>Committed:</strong> The data is stored in your local Git
repository. This is equivalent to an “unmodified” state.</p></li>
</ol>
<hr />
<h2 id="next-steps">Next Steps</h2>
<hr />
<h2 id="summary">Summary</h2>
<hr />
<p><em>© 2025 Ryan Baker ~ Licenced under <a
href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a> ~
Modified: September 24, 2025</em></p>
</body>
</html>
